Stateful Statistics
-------------------
Clearwater is a massively-scalable IMS core. One of the key ways it achieves its scalability by keeping all state in dedicated stores, and leaving the main processing to be stateless. Administrators of any telecoms platform need to be able to monitor the state and performance of the system, and Clearwater provides statistics, such as latency values and transaction success/failures, that allow them to do this. Many of these statistics are event-driven - whenever an event occurs (e.g. a SIP request is handled), Clearwater increments a counter or makes a measurement and accumulates that into its totals. Apart from the totals themselves, Clearwater does not need to maintain any state to do this. However, there are some statistics that don’t fit this model, such as the count of active calls. It’s not enough to count the number of times a call is set up and subtract the number of times a call is torn down - some calls might be torn down twice (e.g. if both ends hang up simultaneously) and some calls are not explicitly torn down at all (e.g. those that time out), so the statistic might diverge from reality. Instead, these statistics depend on the system maintaining state about the list of active "things" (e.g. calls) - we call these "stateful" statistics. Clearwater uses a component called [Chronos](https://github.com/Metaswitch/chronos), which provides a distributed, fault-tolerant timer store. Fortunately, the timers that Chronos stores have exactly the same life-span as the things our stateful statistics want to count. As a result, we can query Chronos to get an accurate view of these statistics in Clearwater. For example, we can describe the life cycle of a timer created for a registration:

1.  To begin, a Sprout process generates the timer structure. Within this structure, a "tags" field allows us to give the category of the timer, such as the string "REG" in this case.
2.  Sprout sends a request to Chronos asking it to store this timer. Embedded in the timer is the point when Sprout would like to receive it back, so from this moment on, Sprout can forget about the timer.
3.  Chronos accepts the timer, and may generate replicas to prevent us from losing timers in the case of a node failure.
4.  When the timer "pops", Chronos examines the timer and will inform the Sprout process, if the timer is still relevant. Chronos may then decide to re-add the timer (if may be repeated) or discard it (if it is no longer needed).

Once Sprout sets the timer, Chronos is completely responsible for the life cycle of the timer. This makes it the ideal component to report accurate statistics related to the number of active timers. Furthermore, as each timer can be tagged with a particular category, Chronos can also report individual types of timer that it has seen. One detail we were careful to avoid was introducing a list of pre-defined tags to Chronos. Firstly, this would tie this component to a particular version of Clearwater, and secondly, any additional tags would require editing Chronos. To cope with this, Chronos dynamically creates statistics whenever it sees a new category of tag. This means future enhancements of more detailed tags such as "VIDEO CALL" or "EMERGENCY CALL" are easily implemented. With this feature, any component of Clearwater that makes use of Chronos is able to tag it with a particular value. This makes it extremely versatile, and can be extended for use with a wide range of tags. If you’d like to see which stateful statistics Clearwater currently supports, or are interested in other statistics Clearwater reports, you can find more information [here](http://clearwater.readthedocs.org/en/stable/Clearwater_SNMP_Statistics/index.html).
